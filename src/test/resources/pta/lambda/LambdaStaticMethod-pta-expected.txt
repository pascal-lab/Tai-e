Points-to sets of all variables
[]:<LambdaStaticMethod$GT: void <init>()>/%this -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[3@L12] new LambdaStaticMethod$GT}]
[]:<LambdaStaticMethod$LE: void <init>()>/%this -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[6@L14] new LambdaStaticMethod$LE}]
[]:<LambdaStaticMethod$Op: void <init>()>/%this -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[3@L12] new LambdaStaticMethod$GT}, []:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[6@L14] new LambdaStaticMethod$LE}]
[]:<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>/$r1 -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[6@L14] new LambdaStaticMethod$LE}]
[]:<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>/$r2 -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[3@L12] new LambdaStaticMethod$GT}]
[]:<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>/r0 -> [[]:NewObj{<LambdaStaticMethod: java.lang.Object test()>[1@L17] new java.lang.Object}]
[]:<LambdaStaticMethod: java.lang.Object test()>/$r0 -> [[]:LambdaObj{alloc=<LambdaStaticMethod: java.lang.Object test()>[0@L10] $r0 = invokedynamic <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)> "apply" <MethodType: java.util.function.Function ()>[MethodType: java.lang.Object (java.lang.Object),MethodHandle[REF_invokeStatic]: <LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>,MethodType: LambdaStaticMethod$Op (java.lang.Object)](),type=java.util.function.Function in <LambdaStaticMethod: java.lang.Object test()>}]
[]:<LambdaStaticMethod: java.lang.Object test()>/$r1 -> [[]:NewObj{<LambdaStaticMethod: java.lang.Object test()>[1@L17] new java.lang.Object}]
[]:<LambdaStaticMethod: java.lang.Object test()>/$r2 -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[3@L12] new LambdaStaticMethod$GT}, []:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[6@L14] new LambdaStaticMethod$LE}]
[]:<LambdaStaticMethod: void main(java.lang.String[])>/r0 -> [[]:EnvObj{alloc=<main-arguments>,type=java.lang.String[] in <LambdaStaticMethod: void main(java.lang.String[])>}]
[]:<java.lang.Object: int hashCode()>/%native-this -> [[]:NewObj{<LambdaStaticMethod: java.lang.Object test()>[1@L17] new java.lang.Object}]
[]:<java.lang.Object: void <init>()>/%this -> [[]:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[3@L12] new LambdaStaticMethod$GT}, []:NewObj{<LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>[6@L14] new LambdaStaticMethod$LE}, []:NewObj{<LambdaStaticMethod: java.lang.Object test()>[1@L17] new java.lang.Object}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r1 -> [[]:MethodHandlesLookupObj{alloc=LambdaStaticMethod,type=java.lang.invoke.MethodHandles$Lookup}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r12 -> [[]:ConstantObj{java.lang.invoke.MethodHandle: MethodHandle[REF_invokeStatic]: <LambdaStaticMethod: LambdaStaticMethod$Op lambda$test$0(java.lang.Object)>}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r15 -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: LambdaStaticMethod$Op (java.lang.Object)}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r3 -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: java.util.function.Function ()}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r6 -> [[]:ConstantObj{java.lang.String: "apply"}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r9 -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: java.lang.Object (java.lang.Object)}]

Points-to sets of all static fields

Points-to sets of all instance fields

Points-to sets of all array indexes
[]:EnvObj{alloc=<main-arguments>,type=java.lang.String[] in <LambdaStaticMethod: void main(java.lang.String[])>}[*] -> [[]:EnvObj{alloc=<main-arguments-element>,type=java.lang.String in <LambdaStaticMethod: void main(java.lang.String[])>}]

